# 八、领域事件

经典的观察者模式，一般用于维护领域系统的一致性，这个一致性一般是最终一致性。一般有以下场景：

1. 本领域内，某实体变更后发出领域事件，其它关联实体监听该事件，更新其关联业务属性。
2. 多限界上下文，核心域实体变更通过消息队列发出领域事件，所有相关的支撑域针对该事件做出相关的反应。
3. 清除分布式缓存或者应用内置缓存。

**领域事件分类**

1. 本地领域事件，即由应用内的其它组件消费的事件
2. 分布式领域事件，即由应用外的其它域的组件消费的事件



**领域事件的存储**

1. 将领域事件进行存储有利于事件追踪
2. 领域事件的存储包括下面方面：
   * 事件存储
   * 事件订阅方处理存储
   * 事件类别定义，即定义事件应该由至少多少个订阅方处理完成方可认为领域事件完全被处理完成。这主要是应对分布式系统中面向失败的设计。

> 这个仍需要用代码来描述，书上讲了一大堆的设计要点，这些都需要用实例来证明其可行性。
>
> 另外也要利用一种可靠的MQ，否则无从谈起。



**分布式领域事件的设计思路**

1. 领域层向领域事件管理组件发送领域事件
2. 领域事件管理组件调用支撑域领域事件微服务存储事件（创建），如果失败，记录在本地存储中，以备再次发布（需要一个机制重试，如分布式任务调度系统xxljob之类的）
3. 领域事件管理组件向本地发布事件，由本地优先处理事件
4. 领域事件管理组件向外部发布事件（通过ＭＱ，异步）

**书本中的本地领域事件**

1. 书中本地领域事件竟然用于做事务性的工作，在一次领域命令被完成时，发布领域事件，由Publisher检查本线程的subscriber，将subscriber的执行合并到本次发起的命令的事务当中。

2. ###### 应用层在调取领域层时，需动态注册subscriber，因为注册是注册本线程的，所以事务是合并在本线程的。

3. 这是一种动态注册subscriber的模式。

4. 这种模式由上层决定下一步怎么做，这种方式挺有趣。我们平时写代码是顺序的：1,2,3,4，而这个模式则是根据状态而做相应的处理。

5. 这个模式并不适合跨限界上下文，仅只适合本地应用。

6. 动态观察者模式

**书本中的远程领域事件**

1. 由于是控制事务的是应用层，所以可能会出现事务未提交事件就已发出的情况，这种情况下会出现很多问题，就是领域事件发送出去了，但是由于事务因下一步的事件处理导致的事务回滚。这种问题非常可怕，所以就不能使用申明式事务了，而只能在代码中执行显式事务，明确事务范围。
2. 对于跨限界上下文的领域事件传播，避免在事务内发出，而应该是在应用层的事务外发出。跨限界上下文的领域事件一般为更为顶层的事件，而不应该为领域层级的事件。
3. 也就是说，由应用层级决定发怎样的事件到别的限界上下文中。
4. 需要强调的是，事件通知是一个应用程序级别上的关注点，而不是一个领域的关注点。也就是说，领域层不应该监听领域事件并处理领域事件，而应该在应用层去做。也就是说，领域层只付责发布领域消息，而不负责消费领域消息。
5. 跨限界上下文的消息发送，应将相关的实体信息一并发送，而不应该只传ID，因为有可能是消息已发送到消费方，而事务未完成，消费方通过API查取ID对应的实体时会导致实体不存在的情况。



## 一些思考

为什么要对领域事件做更多的思考呢？因为领域事件的传播可以跨层级，跨限界上下文的，这里涉及到很多设计决策问题：

1. 事件分成几类
2. 每种分类应该由哪一层级发出
3. 哪一层级应该消费怎么样类别的事件
4. 跨限界上下文事件的发布，是直接发领域事件，还是发翻译过的事件？

一个一个问题地解：

### 1. 事件分成几类

事件应该分为两类：

1. 领域事件，领域层事件，细粒度的事件。
2. 应用事件，应用层事件，粗粒度的事件

### 2. 每种分类应该由哪一层级发出？

1. 领域事件

   领域事件由领域层实体、领域服务根据需求发出。

2. 应用事件

   应用事件由应用层发出：

   * 应用层自行发出，无中生有。一般为应用服务调用领域服务完成一系列的操作后，向其它限界上下文发出。
   * 监听到领域事件后，将领域事件转化成应用事件，向其它限界上下文发出。

### 3. 哪一层级应该消费怎样类别的事件

1. 领域事件

   领域事件由应用层消费。

   但是为什么领域层不能消费呢？

   我们先弄清楚一个点，就是实体本身。实体只关注自身业务逻辑的处理，比方说，假如订单实体、支付交易在同一个子域中，那么订单支付完成后，支付实体只应关注支付本身，完成支付交易本身状态的变更，而不应该影响到订单实体的变更。那么支什交易完成后应该让订单的状态改成“已支付”，这时又该怎么去处理呢？其实这是应用层的工作。应用层调用支付领域服务完成支付交易后，或者随后，或者监听支付交易的领域事件，之后调用订单领域服务，完成订单的状态变更。

   > 由此可知，应用层是对领域调用的一次聚合。聚合完成一次批量操作，而这些操作要么全部成功，要么全部失败。
   >
   > 理解应用层很重要，它并不是简单的薄薄的一层控制层，它是粘连各个领域实体的胶水层，根据各个实体、领域服务的反馈，做出适当的决策，也可以说是适当的控制。
   >
   > 以前我们会将相当多的业务逻辑包装在领域层中，包括对外发送事件，简单地说就是隐藏实现，说得好像理所当然，当然看起来很理想。但是，决定业务之后做什么不做什么的是控制层，而不应该是领域层，所以领域层不应该超过领域层自身范围的外部访问或者决策。
   >
   > 所以领域层应该只关注到自己层次的东西：
   >
   > 1. 自身实体的逻辑
   > 2. 甚至不能关心同领域层内其它实体的逻辑
   > 3. 实体可以通过其它实体获取状态
   > 4. 但是实体不可调用其它实体更新其状态。
   > 5. 当实体操作到一阶段后或许需要更新其它实体的状态，可以通过发关领域事件，由应用层处理。这种思路真的很新奇，却十分有效。
   > 6. 理解书本里的例子，突然间觉得书本的作者太强大了。你永远想不到观察者模式是可以一次性的，那个reset方法才是神来一笔。观察者模式不一定是静态模式，也可是一次性的动态模式，通过线程上下文，相当有才。

2. 应用事件

   从2中可以知道，应用事件是由应用层发出，而消费者应该是：

   1. 其它限界上下文。在应用层通过消息队列发布应用事件，由其它限界上下文的应用层消费。

   2. 用户接口层。一般用户接口层不会监听应用事件，貌似也没有必要。

      > 当层次间的访问是严格控制的，那么一次性的动态观察者模式就相当有必要。
      >
      > 你可以将其理解为回调，我没办法被下层直接调用，那么我可以被下层回调。

### 4. 跨限界上下文事件的发布，是直接发领域事件，还是发翻译过的事件

从前面三点地论述，已经可以得到答案。

跨限界上下文事件的发布应该是由应用层发布，应用层发布的应用事件，所以需要将领域事件翻译成应用事件发布出去。

> 这里论述的东西从纯文字上讲是非常抽象的，就像书本的作者一样，想方设法想把DDD给说清楚，其实读者也很难理解，这也就是为什么DDD很难推广的原因。
>
> DDD在微服务架构出现之前就出现 了，我记得那时好像是2006年左右，我就买了一本DDD的书。当时就没有看懂，虽然我知道它是非常有用的软件理论，但是，书本没有相关的示例，所以太过抽象，无法理解，更无从落地。
>
> 这里需要一个示例项目进行讲解。看完后面的知识后，再做一个大的概括。
>
> 有机会的。
