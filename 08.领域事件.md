# 八、领域事件

经典的观察者模式，一般用于维护领域系统的一致性，这个一致性一般是最终一致性。一般有以下场景：

1. 本领域内，某实体变更后发出领域事件，其它关联实体监听该事件，更新其关联业务属性。
2. 多限界上下文，核心域实体变更通过消息队列发出领域事件，所有相关的支撑域针对该事件做出相关的反应。
3. 清除分布式缓存或者应用内置缓存。

**领域事件分类**

1. 本地领域事件，即由应用内的其它组件消费的事件
2. 分布式领域事件，即由应用外的其它域的组件消费的事件



**领域事件的存储**

1. 将领域事件进行存储有利于事件追踪
2. 领域事件的存储包括下面方面：
   * 事件存储
   * 事件订阅方处理存储
   * 事件类别定义，即定义事件应该由至少多少个订阅方处理完成方可认为领域事件完全被处理完成。这主要是应对分布式系统中面向失败的设计。

> 这个仍需要用代码来描述，书上讲了一大堆的设计要点，这些都需要用实例来证明其可行性。
>
> 另外也要利用一种可靠的MQ，否则无从谈起。



**分布式领域事件的设计思路**

1. 领域层向领域事件管理组件发送领域事件
2. 领域事件管理组件调用支撑域领域事件微服务存储事件（创建），如果失败，记录在本地存储中，以备再次发布（需要一个机制重试，如分布式任务调度系统xxljob之类的）
3. 领域事件管理组件向本地发布事件，由本地优先处理事件
4. 领域事件管理组件向外部发布事件（通过ＭＱ，异步）

**书本中的本地领域事件**

1. 书中本地领域事件竟然用于做事务性的工作，在一次领域命令被完成时，发布领域事件，由Publisher检查本线程的subscriber，将subscriber的执行合并到本次发起的命令的事务当中。

2. ###### 应用层在调取领域层时，需动态注册subscriber，因为注册是注册本线程的，所以事务是合并在本线程的。

3. 这是一种动态注册subscriber的模式。

4. 这种模式由上层决定下一步怎么做，这种方式挺有趣。我们平时写代码是顺序的：1,2,3,4，而这个模式则是根据状态而做相应的处理。

5. 这个模式并不适合跨限界上下文，仅只适合本地应用。

6. 动态观察者模式

**书本中的远程领域事件**

1. 由于是控制事务的是应用层，所以可能会出现事务未提交事件就已发出的情况，这种情况下会出现很多问题，就是领域事件发送出去了，但是由于事务因下一步的事件处理导致的事务回滚。这种问题非常可怕，所以就不能使用申明式事务了，而只能在代码中执行显式事务，明确事务范围。
2. 对于跨限界上下文的领域事件传播，避免在事务内发出，而应该是在应用层的事务外发出。跨限界上下文的领域事件一般为更为顶层的事件，而不应该为领域层级的事件。
3. 也就是说，由应用层级决定发怎样的事件到别的限界上下文中。
4. 需要强调的是，事件通知是一个应用程序级别上的关注点，而不是一个领域的关注点。也就是说，领域层不应该监听领域事件并处理领域事件，而应该在应用层去做。也就是说，领域层只付责发布领域消息，而不负责消费领域消息。
5. 跨限界上下文的消息发送，应将相关的实体信息一并发送，而不应该只传ID，因为有可能是消息已发送到消费方，而事务未完成，消费方通过API查取ID对应的实体时会导致实体不存在的情况。
