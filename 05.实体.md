# 第五章、实体

## 一、什么是实体

书上是这样写的

> 一个实体是一个唯一的东西，并且可以在相当长的一段时间内持续地变化。

两个同类型的对象，无论其它业务属性怎么修改而导致的不同，只要它们的身份标识（identity）一样，它们就是同一个实体。

在系统分析时，我们会首先分析用户故事所述的功能行为，然后再去寻找这些行为相关的对象，这些对象就是实体或者值对象。

而唯一的身份标识和可变性特征是实体和值对象区分开来：

1. 实体是有唯一身份标识的，而值对象没有
2. 实体是可修改的，而值对象是常量，不可修改。

> 至于值对象是什么，干什么用的，下一章有说，我现在也不懂，就先记着吧。



## 二、唯一标识

要先弄清楚唯一标识是什么。

> 在记下后面的笔记之前，我先回忆一个事件。
>
> ＤＳＲ最初的有一个功能需要记录一笔业务记录，按照常规做法是将该业务记录定义为实体，我这边设计了一个UUID作为这个实体的ＩＤ。在Ｅ２Ｅ通信时，都会使用这个ＩＤ作为业务记录标识进行数据传递。
>
> 一切看起来很正常，但是在系统集成的时候，长期混迹于公司项目又懂点技术的ＰＭ在一次Daily Meeting中发现这样的设计后，破口大骂，说没见这样设计，把ＩＤ作为Reference ID在E2E中传递，暴露了内部的业务属性。
>
> 当时我一直懵圈，不传ＩＤ传什么？现在或许有了答案。



在ＤＤＤ中，唯一标识是附带业务属性的身份标识。比如说张三这个名字在一个班里就可以做唯一标识来标识一个学生，因为在这个班里没有第二个人叫张三。但是在大的范围内张三还能当做一个学生的标识吗？比如在一个学校的范围内，极有可能不可以，因为会存在大概两三个张三，这样，这个姓名就不能当做唯一标识，他必须要附加一些属性才能做为唯一标识：某大学某系某级某班张三，当然这样的标识非常麻烦，学校会给第一个学生设一个学号，每个学生的学号都不一样，也可以唯一标识一个学生。学号和附加属性的姓名都能唯一标识一个学生，但是他们之间还是有区别的：

1. 附加属性的姓名：这种是附带业务属性的身份标识，也就是ＤＤＤ中的唯一标识，是从业务规则状态下（不是从软件设计上）怎么能够唯一标识一个业务实体的逻辑。你和你的PO讨论的就是这样的身份标识，ＰＯ是不会和你讨论ＩＤ的，他会告诉你什么公司什么部门之类的业务属性来唯一限定一个业务实体。
2. 学号：这种在ＤＤＤ中叫做委派标识，它不具备业务属性，它存在的唯一作用就是给实体编号便于索引，比如说数据库里的Primary Key。在E2E中，这样的标识又叫做Reference ID。

在通常的设计中，我们极少用到附加属性的姓名这样的身份标识，更多的是用委派标识，一直以来大家都是这么干的，就算是书中作者也是这么做的，前面多个ＩＤ生成的方式都是委派标识。但是，如果有机会，最好还是区分这两者。举个例子，如果你的系统对ＩＤ的安全非常敏感，比方说银行帐号，这个帐号就有业务属性了，虽然也是由计算机生成的，但是如果直接在Ｅ２Ｅ中传递会有安全风险。所以这样的帐号ＩＤ会设计成身份标识，同时会另外建立一个委派标识用于引用它，在Ｅ２Ｅ通信时使用引用标识安全性会大大提高：

1. 委派标识：Primary Key of database
2. 唯一标识：Secondary Key of database

再举一个例子，我们都会使用像微信登录这样的ＳＳＯ，微信给我们的是一个openid，这个ＩＤ对于我们来说是附带业务属性的唯一标识（为什么？因为从业务上讲，它是从微信过来的用户，这就是业务属性），但是这样的唯一标识不可能在我们自己的业务系统中进行E2E传递，我们会给用户设一个本系统的ＩＤ，这个ＩＤ就是委派标识，专用于E2E传递。

> 现在回到开头的案例，ＰＭ的破口大骂是可以理解的，因为把唯一标识用于E2E传递违反了设计原则。但是，ＤＳＲ中这个ＩＤ没有业务属性，仅只是引用业务记录的索引，可以认为这是一个委派标识。委派标识是可以在Ｅ２Ｅ中传递的。
>
> 所以设计是没有问题的（巧合），而ＰＭ是没有深入了解而产生的误会。
>
> 当然，你是大佬，听听就好。

当然，我也想不到，一个ＩＤ都这么讲究。



## 三、实体是否适合ＯＲＭ

> 这一段属于纯思考，或许在后面的学习中需要推翻这里的结论

我们要重新思考实体是什么。

常规意识里一直认为实体就是ORM里定义的需要存进数据库里的数据表映射记录，比方说我有一个用户表，用户表的每一行记录就能对应我们应用的一个实体对象，一直以来都是这样认为的。

在接触ＯＲＭ之后我也是这样认为的，但是之前并不是，因为在读的一本书（忘记书名）中说的面向接口的编程有一段思想是这样的：分离业务与实现，将业务代码实现成纯业务代码，而这些代码并不依赖于具体的实现，而是依赖于接口，而接口的实现则负责落盘、访问远端系统等。这个思想是在IoC和DＩ思想出现之前，更严格的说是在SpringFramework出现之前，不过书中只是描述了这样的方法，却没有实际的实现，更不用说什么示例代码了。

反观ＤＤＤ，其实和上面说的很相似，在领域层中，它极力要实现的就是纯代码，避免技术框架对领域层的影响，也就是说，你的代码和SpringFramework、JPA、Hibernate ORM没有任何关系，它甚至可以独立出来测试，它依赖的每一个接口都可通过ＭＯＣＫ来让测试可以执行。

在这样的背景下，ＤＤＤ的实体概念和ＯＲＭ的实体概念就不是同一个东西了。

ＤＤＤ的实体分层架构中领域层中的东西，它基于业务逻辑，它对业务领域进行建模，尽最大可能与业务领域同步，它不用思考怎么去存储，它只是依赖一个接口去把它存到存储中，至于是存进数据库还是NoSQL，它是不管的。也就是说，它只管业务属性，它不管质量属性。

所以往往在落地ＤＤＤ的项目会出现一个叫ＰＯ这样的东西。

> 第一次接触ＤＤＤ项目的时候，我就疑惑这个东西，为什么这个东西会存在，平白无由地多出来这么一层。

其实就是增加一个Persistent层去实现领域层定义的接口，如果是数据库存储并且用到ＯＲＭ的话，那么就需要定义一系列的ＰＯ，以及一系统对应的Repository。它们处于分层架构的基础设施层，为的只是把ＤＤＤ的实体存储到目标存储中，并且把它读取出来。

这里仍然写得很抽象，需要示例代表，准备中。