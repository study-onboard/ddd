# 第四章、架构

## 一、架构演进

1. 分层
2. ＤＩＰ依赖倒置
3. 六边形
4. ＣＱＲＳ



## 二、分层架构

<img src="./assets/images/layer-structure.jpeg" alt="img" style="zoom: 33%;" />

1. 用户接口层：可以看作为是api层，比如grpc / rest api / openapi等等。它包括对请求数据的校验。它和应用层是一对一的关系，也就是一个endpoint对应于应用层的一个方法。它校验请求数据之后，调用应用层接口处理请求。

2. 应用层：可以用于控制持久化事务和安全认证

   * 它聚合领域层操作，决定这些聚合的操作要么全部成功，要么全部失败
   * 它检查访问权限，决定请求是否可以访问相关的功能。
   * 可以简单认为他是外部对本领域操作的实现，无论采用的是什么格式（REST API / GRPC.....）

   应用层很薄，也应该设计得很薄。

3. 领域层，抽象的业务逻辑层。为什么是抽象呢？因为他不需要知道具体是怎么存储数据或者具体是怎么发送消息的。这一层所有的调用都是面向接口的调用，而具体的实现，则是由基础设施层去实现。

   举个例子：领域层有一个创建订单的业务方法，它调用OrderRepository这个interface的save方法去持久化订单，至于这个持久化是存入数据库呢还是调用什么别的存储，它是不用理会的，而理会的是基础设施层自己的实现。基础设施层的实现可以选择保存在数据库里，也可以选择调用别的外部服务去存储。

   在这一层中存在着这样大量的定义接口，例如：MessageAdaptor / NotificationAdaptor之类的，领域层只是负责处理业务逻辑，调用接口完成业务逻辑的需求，而接口的实现则是由基础设施层去做。

4. 基础设施层，可以理解为对领域层定义的能力的实现。

> 这是我在学习面向接口编程的时候就想到的方法，大概在Evans的书出来第一版的时候。但是那时这本书真没办法实施落实，所以也就没有往这个方向去看。

分层架构的一个重要的原则：每层只能与位于其下方的层发生的耦合。也就是说，不能跨层访问，也不能反方向访问，即底层访问上层。

不过也有方式可以让底层访问上层，仅只有一种方式：回调。上层实现底层定义的回调接口，然后将这个实现当成参数传入到底层方法中，当底层方法处理完后，通过调用实现回调上层。



## 三、依赖倒置原则

其实就是分层架构。不过定义了更为合理实现原则。

1. 由上层定义下层应实现的能力
2. 由下层去实现上层定义的能力
3. 上层通过框架的依赖注入功能，将下层的实现注入到本层中，其实就是本文之前对分层架构的讲述一样。

> 书中所说的反向依赖其实是下层对上层定义的接口的依赖。

### 一些想法

以前都是站在供应商的方式去思考着的，将下层看成是供应商，供应商定义自己能够实现的能力，让上层去挑选使用，往往这样需要定义大量的接口方法，而不论这里接口方法是否真的会被使用到。而上层则是要聚合大量方法才能实现一个功能，哪怕这些功能很多地方并不是本层所需要的（你提供了一水桶的水，而我只要一勺）。

而DDD的思想则是相反，它只定义上层对下层的需求，将其定义为接口，而下层则需要按上层的要求去实现。这样的方式减少了大量的浪费，而且目的非常明确，直击需求。

后面的开发会按照这样的模式去安排，觉得颇为有效。



## 四、六边形架构

1. 在六边形架构中，不同的客户通过“平等”的方式与系统交互。
2. 来个新的客户，只需要添加一个新的适配器将客户输入转化成能被系统ＡＰＩ所理解的参数就可以了。
3. 系统的输出，诸如图形界面、消息、接口等都可以通过不同的方式实现。
4. 很多分层架构其实实际上使用的是六边形架构。

<img src="https://yqfile.alicdn.com/bd27964af93166bd1ed312b1a56c523a7745ecf9.png" alt="bd27964af93166bd1ed312b1a56c523a7745ecf9" style="zoom:50%;" />

六边形架构分为两个区域：

1. 外部区域：接收不同客户提交的输入，将输入转化成内部区域的输入。
2. 内部区域：获取持久化数据，并对程序输出进行存储，或者转发数据。

每种类型的客户都有它自己的适配器，该适配器用于将客户输入转化为程序内部API所能理解的输入。

六边形每条不同的边代表不同种类型的端口，端口要么处理输入，要么处理输出。可以这么理解，每一边代表一种通信协议，如ＨＴＴＰ，ＴＣＰ等，一边可以有多个适配器，每一个适配器代表一种数据协议：gRPC / Rest API / SOAP 等。当客户请求到达时，都应该有相应的适配器对输入进行转化，然后端口将调用应用程序的某个操作或者向应用程序发送一个事件，控制权由此交给内部区域。



> **一些理解**
>
> 这里六边形架构中，外部区域并不是分层架构中的用户接口层，而是用户接口层之外的一层。
>
> 用户接口层等分层都属于内部区域，用户接口层则是提供通用的ＡＰＩ接口，比方说RestAPI，如果你有XML的输入，用户接口层并不再提供相应的输入点，而是在用户接口层外，也就是外部区域创建相应的适配器将ＸＭＬ转化成通用ＡＰＩ接口所能读取的数据。
>
> 外部访问本领域的ＡＰＩ时，也是通过相应的端口访问，而不能直接访问ＡＰＩ。访问分为两种：
>
> 1. 外部客户访问，往往这种访问附带用户信息，比如jwt token之类的，而往往本域有些请求需要访问别的支撑域或者通用子域的ＡＰＩ才能完成用户的请求。这时就需要在外部区域增加输出适配器（往往内置或者更为轻量的微服务）组装请求（比如拼凑ＨＥＡＤＥＲ之类的）以访问支撑域或者通用子域的外部区域端口。
> 2. 内部e2e访问，这类访问不是由用户发起，而是由服务内部发起，比如定时任务、流程引擎等，这类请求也是需要访问外部区域的端口，验证输入的e2e token，而访问支撑域或者通用子域ＡＰＩ时，也是要生成相应的e2e token，访问相应的端口。
>
> 从上面的讨论，内部区域的用户接口层的接口定义应该与具体输入端口无关，它就是一种service api，也就是工具型ＡＰＩ。
>
> 由此，六边形架构是对原分层架构的扩展。六边形架构建立的意义在于清楚地描述输入渠道，表明进入分层架构之前的外部情况。
>
> 所以在开发时，应针对用户故事来开发用户接口层，而不是针对外部区域的适配置来开发。也就是，先开发用户接口层，然后再开发相应的适配器。



> **关于e2e调用的理解**
>
> 前面讲了外部客户访问这一块，其实有一个很明显的逻辑冲突：当内部区域已经无区别各种适配输入，那么也就是说它也就不持有外部客户相关认证信息，比如说jwt token之类的，当它要调用支撑域以完成请求时，因没有这些认证信息，所以他是无法完成像外部区域一样访问支撑域的，而只能动用内部的e2e访问。
>
> 所以可以总结出一个架构规则：
>
> 1. 内部各子域间的访问只能通过e2e访问，而无法做到附带认证信息的访问
> 2. bff api是一个例外，它聚合所有的子域的ＡＰＩ，因为是聚合，所以它是可以不遵循分层架构的。
>
> 当然，如果将外部区域和内部区域都集成在一个工程内部的话，当然可以实现带认证信息的ＡＰＩ访问。
>
> 从书中后续的讲述来看，它的确是认为将外部区域和内部区域都集成在一个工程内部的。



> **关于存储层的思考**
>
> 在上一家公司（做银行业务的），它采用的微服务架构，将微服务分为eapi / papi / sapi，其中sapi负责存储，papi负责业务逻辑，eapi负责处理输入。
>
> 我现在明白他的意思了，其实它采用的就是六边形架构，印度三哥果然牛逼。
>
> 一开始我并不理解sapi的用途，一直以为sapi就是service api，用于处理业务逻辑的，而papi是portal api，处理用户输入的，而eapi则是一种为了达到安全要求而设立的一种适配层。在项目进行过程中，我们一直按这个思路去做，直到和一些老程序员一起code reivew的时候，明显思路对不上，我们迷惑，他们也没办法说清楚。明显，我们违反了架构设计的原则，而他们则没有理解这个架构原则。
>
> 所以，
>
> 对于内部区域来说，它关注的是业务逻辑，而并不关注如何存储，如何应答请求，所以也就会存在输入适配器和输出适配器这样的东西了。
>
> 但是像上面说的那个用一个sapi专门来处理存储也不合理，对于处理事务来说，一次对处请求属于一次事务，而在应用层聚合的领域层会导致多次存存储请求，从而导致本应一次事务处理的请求到了存储成变成了多次事务，从而达不到事务的原子性。所以一般来说，数据库存储应内置在内部区域。而非数据库事务存储则可以置于外部区域，比如文件、对象存储等。



> **六边形架构与分层架构的思考**
>
> 在我看来这两货就是一个货。
>
> 只是分层架构的`基础设施层`变成了外部区域的输出适配器而已。
>
> 所以，六边形架构就是一个把`基础设施层`改成外部区域的输出适配器而已。



## 五、面向服务的架构

